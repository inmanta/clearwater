import openstack
import ubuntu
import clearwater
import ssh
import ip

entity ManagedClearWater extends ClearWater:
    number ellis_instances
    number bono_instances
    number sprout_instances
    number homer_instances
    number vellum_instances
    number dime_instances

    bool memento

    string image_id
    string flavor
end

std::OS vm_os                       [1] -- [0:] ManagedClearWater mcw

openstack::Network external_network [1] -- [0:] ManagedClearWater mcw
openstack::Provider provider        [1] -- [0:] ManagedClearWater mcw
openstack::Project project          [1] -- [0:] ManagedClearWater mcw
openstack::Subnet mgmt_network      [1] -- [0:] ManagedClearWater mcw
ssh::Key key_pair                   [1] -- [0:] ManagedClearWater mcw
openstack::SecurityGroup base_group [1] -- [0:] ManagedClearWater mcw
openstack::SecurityGroup sg_ellis   [1] -- [0:] ManagedClearWater mcw_ellis
openstack::SecurityGroup sg_bono    [1] -- [0:] ManagedClearWater mcw_bono
openstack::SecurityGroup sg_sprout  [1] -- [0:] ManagedClearWater mcw_sprout
openstack::SecurityGroup sg_dime    [1] -- [0:] ManagedClearWater mcw_homestead
openstack::SecurityGroup sg_homer   [1] -- [0:] ManagedClearWater mcw_homer
openstack::SecurityGroup sg_vellum  [1] -- [0:] ManagedClearWater mcw_ralf

entity ClearwaterVNF:
    """
        A baseclass for a clearwater VNF. This VNF defines the VNFC
    """
    string name
end

entity Host extends openstack::Host, clearwater::Host:

end
implement Host using std::hostDefaults, mInmantaAgent, clearwater::privateIP, openstack::openstackVM
implement Host using openstack::eth0Port when subnet is defined
implement Host using clearwater::hostRecords when clearwater.create_dns_records

Host hosts [1:] -- [1] ClearwaterVNF vnf
ClearwaterService services [0:] -- [1] ClearwaterVNF vnf
ManagedClearWater clearwater [1] -- [0:] ClearwaterVNF vnfs

entity Homer extends ClearwaterVNF:

end
implement Homer using mHomer

entity Ellis extends ClearwaterVNF:

end
implement Ellis using mEllis

entity Bono extends ClearwaterVNF:

end
implement Bono using mBono

entity Sprout extends ClearwaterVNF:
    bool memento=true
end
implement Sprout using mSprout
implement Sprout using mSproutMemento when memento

entity Dime extends ClearwaterVNF:

end
implement Dime using mDime

entity Vellum extends ClearwaterVNF:

end
implement Vellum using mVellum

implementation mDefaults for ManagedClearWater:
    self.vm_os = ubuntu::ubuntu1404

    sg_base = openstack::SecurityGroup(provider=provider, project=project, name="cw_base", description="Clearwater base")
    openstack::IPrule(group=sg_base, direction="egress", ip_protocol="all", remote_prefix="0.0.0.0/0")
    openstack::IPrule(group=sg_base, direction="ingress", ip_protocol="icmp", remote_prefix="0.0.0.0/0")
    openstack::IPrule(group=sg_base, direction="ingress", ip_protocol="tcp", port=22, remote_prefix="0.0.0.0/0")
    openstack::IPrule(group=sg_base, direction="ingress", ip_protocol="udp", port_min=161, port_max=162, remote_prefix="0.0.0.0/0")
    openstack::IPrule(group=sg_base, direction="ingress", ip_protocol="tcp", port=2380, remote_prefix="0.0.0.0/0")
    openstack::IPrule(group=sg_base, direction="ingress", ip_protocol="tcp", port=4000, remote_prefix="0.0.0.0/0")

    self.base_group = sg_base

    # Create VNFs
    Homer(clearwater=self)
    Ellis(clearwater=self)
    Dime(clearwater=self)
    Bono(clearwater=self)
    Vellum(clearwater=self)
    Sprout(clearwater=self)
end

implementation mInmantaAgent for openstack::Host:
    env_name = std::environment_name()
    env_id = std::environment()
    env_server = std::environment_server()
    port = std::server_port()
    release = std::get_env("INMANTA_RELEASE", "stable")

    self.user_data = std::template("clearwater/user_data.j2")
end

implement ManagedClearWater using mDefaults
implement ManagedClearWater using clearwaterDNS when create_dns_records

## Each implementation start the required number of virtual machines and setup security groups
## http://clearwater.readthedocs.io/en/stable/Clearwater_IP_Port_Usage.html

implementation mEllis for Ellis:
    self.name = "ellis"
    sg = openstack::SecurityGroup(provider=clearwater.provider, project=clearwater.project, name="cw_ellis", description="Clearwater ellis WebUI")
    clearwater.sg_ellis = sg

    # Web interface
    openstack::IPrule(group=sg, direction="ingress", ip_protocol="tcp", port=80, remote_prefix="0.0.0.0/0")
    openstack::IPrule(group=sg, direction="ingress", ip_protocol="tcp", port=443, remote_prefix="0.0.0.0/0")

    for i in std::sequence(clearwater.ellis_instances, 1):
        host = Host(provider=clearwater.provider, project=clearwater.project, name="ellis-{{i}}.{{clearwater.private_domain}}",
                    image=clearwater.image_id, flavor=clearwater.flavor, key_pair=clearwater.key_pair, os=ubuntu::ubuntu1404,
                    subnet=clearwater.mgmt_network, vnf=self)
        host.vm.security_groups=[clearwater.base_group, sg]

        clearwater::Ellis(clearwater=clearwater, host=host, instance_name="{{ name }}-{{i}}", vnf=self)

        fip = openstack::FloatingIP(provider=clearwater.provider, project=clearwater.project, external_network=clearwater.external_network,
                                    port=host.vm.eth0_port)
        host.public_ip = ip::IP(v4=std::getfact(fip, "ip_address"))
    end
end

implementation mBono for Bono:
    self.name = "bono"
    sg = openstack::SecurityGroup(provider=clearwater.provider, project=clearwater.project, name="cw_bono", description="Clearwater bono")
    clearwater.sg_bono = sg
    # STUN signaling
    openstack::IPrule(group=sg, direction="ingress", ip_protocol="tcp", port=3478, remote_prefix="0.0.0.0/0")
    openstack::IPrule(group=sg, direction="ingress", ip_protocol="udp", port=3478, remote_prefix="0.0.0.0/0")

    # SIP signaling:
    openstack::IPrule(group=sg, direction="ingress", ip_protocol="tcp", port=5060, remote_prefix="0.0.0.0/0")
    openstack::IPrule(group=sg, direction="ingress", ip_protocol="udp", port=5060, remote_prefix="0.0.0.0/0")
    openstack::IPrule(group=sg, direction="ingress", ip_protocol="tcp", port=5062, remote_prefix="0.0.0.0/0")

    # RTP forwarding
    openstack::IPrule(group=sg, direction="ingress", ip_protocol="udp", port_min=32768, port_max=65535,
                      remote_prefix="0.0.0.0/0")

    # Internal sip signaling
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=5058, remote_group=sg)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=5058, remote_group=clearwater.sg_sprout)

    for i in std::sequence(clearwater.bono_instances, 1):
        host = Host(provider=clearwater.provider, project=clearwater.project, name="bono-{{i}}.{{clearwater.private_domain}}",
                    image=clearwater.image_id, flavor=clearwater.flavor, key_pair=clearwater.key_pair, os=ubuntu::ubuntu1404,
                    subnet=clearwater.mgmt_network, vnf=self)
        host.vm.security_groups = [clearwater.base_group, sg]

        clearwater::Bono(clearwater=clearwater, host=host, instance_name="{{ name }}-{{i}}", vnf=self)

        fip = openstack::FloatingIP(provider=clearwater.provider, project=clearwater.project, external_network=clearwater.external_network,
                                    port=host.vm.eth0_port)
        host.public_ip = ip::IP(v4=std::getfact(fip, "ip_address"))
    end
end

implementation mSprout for Sprout:
    self.name="sprout"
    sg = openstack::SecurityGroup(provider=clearwater.provider, project=clearwater.project, name="cw_sprout", description="Clearwater sprout")
    clearwater.sg_sprout = sg

    # Internal sip signaling
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=5052, remote_group=sg)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=5052, remote_group=clearwater.sg_bono)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=5054, remote_group=sg)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=5054, remote_group=clearwater.sg_bono)

    # Chronos
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=7253, remote_group=sg)

    # Homestead registration
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=9888, remote_group=clearwater.sg_dime)

    for i in std::sequence(clearwater.sprout_instances, 1):
        host = Host(provider=clearwater.provider, project=clearwater.project, name="sprout-{{i}}.{{clearwater.private_domain}}",
                    image=clearwater.image_id, flavor=clearwater.flavor, key_pair=clearwater.key_pair, os=ubuntu::ubuntu1404,
                    subnet=clearwater.mgmt_network, vnf=self)
        host.vm.security_groups = [clearwater.base_group, sg]

        clearwater::Sprout(clearwater=clearwater, host=host, memento=memento, instance_name="{{ name }}-{{i}}", vnf=self)
    end
end

implementation mSproutMemento for Sprout:
    # HTTPS
    openstack::IPrule(group=clearwater.sg_sprout, direction="ingress", ip_protocol="tcp", port=443, remote_prefix="0.0.0.0/0")
end

implementation mHomer for Homer:
    self.name = "homer"
    sg = openstack::SecurityGroup(provider=clearwater.provider, project=clearwater.project, name="cw_homer", description="Clearwater homer")
    clearwater.sg_homer = sg

    # REST interface
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=7888, remote_group=clearwater.sg_sprout)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=7888, remote_group=clearwater.sg_ellis)

    for i in std::sequence(clearwater.homer_instances, 1):
        host = Host(provider=clearwater.provider, project=clearwater.project, name="homer-{{i}}.{{clearwater.private_domain}}",
                    image=clearwater.image_id, flavor=clearwater.flavor, key_pair=clearwater.key_pair, os=ubuntu::ubuntu1404,
                    subnet=clearwater.mgmt_network, vnf=self)
        host.vm.security_groups = [clearwater.base_group, sg]

        clearwater::Homer(clearwater=clearwater, host=host, instance_name="{{ name }}-{{i}}", vnf=self)
    end
end

implementation mDime for Dime:
    self.name = "dime"
    sg = openstack::SecurityGroup(provider=clearwater.provider, project=clearwater.project, name="cw_dime", description="Clearwater dime")
    clearwater.sg_dime = sg

    # REST interface
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=8888, remote_group=clearwater.sg_sprout)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=8888, remote_group=clearwater.sg_ellis)

    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=8889, remote_group=clearwater.sg_ellis)

    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=10888, remote_group=clearwater.sg_sprout)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=10888, remote_group=clearwater.sg_bono)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=10888, remote_group=clearwater.sg_vellum)


    for i in std::sequence(clearwater.dime_instances, 1):
        host = Host(provider=clearwater.provider, project=clearwater.project, name="dime-{{i}}.{{clearwater.private_domain}}",
                    image=clearwater.image_id, flavor=clearwater.flavor, key_pair=clearwater.key_pair, os=ubuntu::ubuntu1404,
                    subnet=clearwater.mgmt_network, vnf=self)
        host.vm.security_groups = [clearwater.base_group, sg]

        clearwater::Dime(clearwater=clearwater, host=host, instance_name="{{ name }}-{{i}}", vnf=self)
    end
end

implementation mVellum for Vellum:
    self.name = "vellum"
    sg = openstack::SecurityGroup(provider=clearwater.provider, project=clearwater.project, name="cw_vellum", description="Clearwater vellum")
    clearwater.sg_vellum = sg

    # Chronos, memcached and Cassandra
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=7253, remote_group=clearwater.sg_vellum)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=11211, remote_group=clearwater.sg_vellum)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=7000, remote_group=clearwater.sg_vellum)

    # Chronos and Astaire
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=7253, remote_group=clearwater.sg_vellum)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=11311, remote_group=clearwater.sg_vellum)

    # Cassandra clients
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=9160, remote_group=clearwater.sg_homer)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=9160, remote_group=clearwater.sg_dime)
    openstack::GroupRule(group=sg, direction="ingress", ip_protocol="tcp", port=9160, remote_group=clearwater.sg_sprout)        

    for i in std::sequence(clearwater.vellum_instances, 1):
        host = Host(provider=clearwater.provider, project=clearwater.project, name="vellum-{{i}}.{{clearwater.private_domain}}", image=clearwater.image_id,
                    flavor=clearwater.flavor, key_pair=clearwater.key_pair, os=ubuntu::ubuntu1404, subnet=clearwater.mgmt_network, vnf=self)
        host.vm.security_groups = [clearwater.base_group, sg]

        clearwater::Vellum(clearwater=clearwater, host=host, instance_name="{{ name }}-{{i}}", vnf=self)
    end
end
