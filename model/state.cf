"""
    This module contains state machines required to perform operation on clearwater

    :copyright: 2017 Inmanta NV
    :contact: code@inmanta.com
"""
import state
import clearwater
import exec

entity VNFCState extends state::StateMachine:
    """
        This entity models the state machine that manages an instance (VNFC) of a VNF
    """
end

VNFCState.service [1] -- clearwater::ClearwaterService.fsm [1]

initial = state::State(name="initial", values={"dns_records": false, "decommission": false})
up = state::State(name="up", label="success", values={"dns_records": true, "decommission": false})
decommission = state::State(name="decommission", label="warning", values={"dns_records": false, "decommission": true})
remove = state::State(name="remove", label="warning", values={"dns_records": false, "decommission": false})
error = state::State(name="error", label="danger", values={"dns_records": true, "decommission": false})

implementation vnfcFSMConfig for VNFCState:
    """
        This implementation configures the state machine
    """
    # Give the FSM its config
    self.config = state::StateConfig(
        states=[initial, up, decommission, remove, error],
        initial_state=initial,
        allowed_transfers=[
            state::StateTransfer(from=initial, to=up, error=error),
            state::StateTransfer(from=up, to=decommission, error=error),
            state::StateTransfer(from=decommission, to=remove, error=error)
            #state::StateTransfer(from=configured, to=started, transition=starting, error=error, operation="start"),
            #state::StateTransfer(from=started, to=configured, transition=stopping, error=error, operation="stop"),
            #state::StateTransfer(from=configured, to=initial, transition=deleting, error=error, operation="delete")
        ]
    )

    # Set the current state (stored in the orchestrator)
    self.name = "{{ service.vnf_name }}_{{ service.vnf_instance }}"
    self.state = state::current_state(self)
end

implementation vnfcStateConfig for VNFCState:
    """
        This implementation sets variables on the VNFC in all states. Use this for example to set variables based on
        values attached to the state.
    """
    self.service.create_dns_records = state::fsmvalue(self, "dns_records")
    self.service.decommission = state::fsmvalue(self, "decommission")
end
implement VNFCState using vnfcFSMConfig, vnfcStateConfig

implementation vnfcInitial for VNFCState:
    """
        The configuration for the initial state. The FSM progresses to the UP state when clearwater indicates that the
        configuration has been synchronised (cw-check_config_sync)
    """
    check = exec::Run(host=self.service.host, requires=self.service.cw_mgmt, send_event=true,
                      command="/usr/bin/cw-check_config_sync")
    state::Transition(fsm=self, to=up, on_error=initial, requires=[check, self.requires])
end

implement VNFCState using vnfcInitial when self.state == initial

implementation vnfcUp for VNFCState:
    """
        The configuration for the up state. This is mainly required to keep the state parameter resource active. When a VNFC
        is removed from the model, it can be purged with purge_on_delete.
    """
    state::Transition(fsm=self, to=up, on_error=initial, requires=self.requires)
end

implement VNFCState using vnfcUp when self.state == up

implementation vnfcDecommission for VNFCState:
    """
        The configuration for the decommission state.
    """
    state::Transition(fsm=self, to=remove, on_error=remove, requires=self.requires)
end

implement VNFCState using vnfcDecommission when self.state == decommission

implementation vnfcRemove for VNFCState:
    """
        The configuration for the remove state. This will also remove the state param from server. This will kick-in the
        purge_on_delete mechanism.
    """
end
implement VNFCState using vnfcRemove when self.state == remove

implementation vnfError for VNFCState:
    check = exec::Run(host=self.service.host, requires=self.service.cw_mgmt, send_event=true,
                      command="/bin/true")
    state::Transition(fsm=self, to=initial, on_error=error, requires=check)
end
implement VNFCState using vnfError when self.state == error